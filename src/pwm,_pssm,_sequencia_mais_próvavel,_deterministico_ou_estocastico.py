# -*- coding: utf-8 -*-
"""PWM, PSSM, Sequencia mais próvavel, deterministico ou estocastico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxwnA2T9cNcqSN3F2Se5UWJaoQFbA_Nc
"""

import pprint
from math import log2, prod, isclose
from re import findall
from math import isclose

"""Função para calcula PWM, PSSM e sequência mais provavél"""

def pwm_pssm_e_sequencia_mais_provavel(seqs, seq, tipo="DNA", pseudocontagem=0, casas_decimais=2, bg_freq=None):
    """
    Calcula a PWM, a PSSM, a probabilidade de uma sequência e encontra a subsequência mais provável.

    Args:
        seqs: Lista de sequências para calcular a PWM e a PSSM.
        seq: Sequência para calcular a probabilidade e a subsequência mais provável.
        tipo: "DNA" (padrão) ou "PROTEIN".
        pseudocontagem: Valor da pseudocontagem (padrão: 0).
        casas_decimais: Número de casas decimais para arredondar os valores da PWM e PSSM.
        bg_freq: Frequências de fundo para o cálculo da PSSM (dicionário opcional).

    Returns:
        pwm: Matriz de Pesos de Posição (PWM).
        pssm: Matriz de Scores Específicos de Posição (PSSM).
        prob_seq: Probabilidade da sequência fornecida.
        seq_mais_probavel: Subsequências mais prováveis com sua probabilidade.
    """
    from math import log2, prod
    from re import findall

    if not seqs:
        raise ValueError("A lista de sequências não pode estar vazia!")

    if not all(len(seqs[0]) == len(s) for s in seqs):
        raise ValueError("Todas as sequências na entrada devem ter o mesmo comprimento!")

    if len(seq) < len(seqs[0]):
        raise ValueError("A sequência fornecida deve ser maior ou igual ao comprimento do motivo!")

    tipo = tipo.upper()
    alfabeto = {"DNA": "ACGT", "PROTEIN": "ARNDCQEGHILKMFPSTWYVBZX_"}.get(tipo)
    if not alfabeto:
        raise ValueError(f"Tipo inválido: {tipo}. Escolha entre 'DNA' ou 'PROTEIN'.")

    if bg_freq is None:
        bg_freq = {b: 1 / len(alfabeto) for b in alfabeto}

    if not all(b in bg_freq for b in alfabeto):
        raise ValueError("As frequências de fundo devem cobrir todo o alfabeto.")

    if not all(c in alfabeto for s in seqs for c in s):
        raise ValueError("As sequências contêm caracteres inválidos para o alfabeto escolhido.")
    if not all(c in alfabeto for c in seq):
        raise ValueError("A sequência contém caracteres inválidos para o alfabeto escolhido.")

    L, A = len(seqs[0]), len(alfabeto)
    tabela = [{b: sum(s[i] == b for s in seqs) + pseudocontagem for b in alfabeto} for i in range(L)]

    pwm = [{k: v / (len(seqs) + A * pseudocontagem) for k, v in linha.items()} for linha in tabela]

    pssm = [
        {k: round(log2(pwm[i][k] / bg_freq[k]), casas_decimais) if pwm[i][k] > 0 else float("-inf")
         for k in pwm[i]}
        for i in range(L)
    ]

    prob_seq = prod(pwm[i].get(seq[i], 0) for i in range(len(pwm)) if seq[i] in pwm[i])

    motif_len = len(pwm)
    subseqs = findall(f'(?=(.{{{motif_len}}}))', seq)
    subseqs = [s for s in subseqs if all(c in pwm[0] for c in s)]
    probs = {s: prod(pwm[i].get(s[i], 0) for i in range(motif_len)) for s in subseqs}
    max_prob = max(probs.values(), default=0)
    seqs_mais_probaveis = sorted(k for k, v in probs.items() if v == max_prob)

    return pwm, pssm, prob_seq, (seqs_mais_probaveis, max_prob)

"""Função para encontrar motivos determinísticos ou estocásticos"""

def encontrar_motivos(seqs, pwm=None, tipo="deterministico", threshold=0.1):
    """
    Encontra motivos determinísticos ou estocásticos nas sequências fornecidas.

    - Motivos determinísticos são padrões exatos que aparecem em todas as sequências.
    - Motivos estocásticos são determinados com base nas probabilidades da PWM.

    Args:
        seqs: Lista de sequências (de DNA ou proteína) para procurar os motivos.
        pwm: PWM calculada a partir das sequências (necessária para motivos estocásticos).
        tipo: Tipo de motivo a ser encontrado, pode ser "deterministico" ou "estocastico".
        threshold: Limite de probabilidade para considerar um motivo válido (apenas para motivos estocásticos).

    Returns:
        motivos: Lista com os motivos encontrados.
    """
    if tipo == "deterministico":
        L = len(seqs[0])
        motivos = []

        for i in range(len(seqs[0]) - L + 1):
            subseq = seqs[0][i:i+L]
            if all(subseq in s for s in seqs):
                motivos.append(subseq)

        return list(set(motivos))

    elif tipo == "estocastico":
        if pwm is None:
            raise ValueError("PWM deve ser fornecida para encontrar motivos estocásticos.")

        L = len(pwm)
        motivos_estocasticos = []

        for seq in seqs:
            from re import findall
            subseqs = findall(f'(?=(.{{{L}}}))', seq)
            for subseq in subseqs:
                prob = 1
                for i in range(L):
                    prob *= pwm[i].get(subseq[i], 0)

                if prob >= threshold:
                    motivos_estocasticos.append(subseq)

        return list(set(motivos_estocasticos))

    else:
        raise ValueError("Tipo inválido. Escolha entre 'deterministico' ou 'estocastico'.")
