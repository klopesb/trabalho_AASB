# -*- coding: utf-8 -*-
"""PWM, PSSM, Sequencia mais próvavel, deterministico ou estocastico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxwnA2T9cNcqSN3F2Se5UWJaoQFbA_Nc
"""

import pprint
import unittest
from math import log2, prod, isclose
from re import findall
from math import isclose

"""Função para calcula PWM, PSSM e sequência mais provavél"""

def pwm_pssm_e_sequencia_mais_provavel(seqs, seq, tipo="DNA", pseudocontagem=0, casas_decimais=2, bg_freq=None):
    """
    Calcula a PWM, a PSSM, a probabilidade de uma sequência e encontra a subsequência mais provável.

    Args:
        seqs: Lista de sequências para calcular a PWM e a PSSM.
        seq: Sequência para calcular a probabilidade e a subsequência mais provável.
        tipo: "DNA" (padrão) ou "PROTEIN".
        pseudocontagem: Valor da pseudocontagem (padrão: 0).
        casas_decimais: Número de casas decimais para arredondar os valores da PWM e PSSM.
        bg_freq: Frequências de fundo para o cálculo da PSSM (dicionário opcional).

    Returns:
        pwm: Matriz de Pesos de Posição (PWM).
        pssm: Matriz de Scores Específicos de Posição (PSSM).
        prob_seq: Probabilidade da sequência fornecida.
        seq_mais_probavel: Subsequências mais prováveis com sua probabilidade.
    """
    from math import log2, prod
    from re import findall

    if not seqs:
        raise ValueError("A lista de sequências não pode estar vazia!")

    if not all(len(seqs[0]) == len(s) for s in seqs):
        raise ValueError("Todas as sequências na entrada devem ter o mesmo comprimento!")

    if len(seq) < len(seqs[0]):
        raise ValueError("A sequência fornecida deve ser maior ou igual ao comprimento do motivo!")

    tipo = tipo.upper()
    alfabeto = {"DNA": "ACGT", "PROTEIN": "ARNDCQEGHILKMFPSTWYVBZX_"}.get(tipo)
    if not alfabeto:
        raise ValueError(f"Tipo inválido: {tipo}. Escolha entre 'DNA' ou 'PROTEIN'.")

    if bg_freq is None:
        bg_freq = {b: 1 / len(alfabeto) for b in alfabeto}

    if not all(b in bg_freq for b in alfabeto):
        raise ValueError("As frequências de fundo devem cobrir todo o alfabeto.")

    if not all(c in alfabeto for s in seqs for c in s):
        raise ValueError("As sequências contêm caracteres inválidos para o alfabeto escolhido.")
    if not all(c in alfabeto for c in seq):
        raise ValueError("A sequência contém caracteres inválidos para o alfabeto escolhido.")

    L, A = len(seqs[0]), len(alfabeto)
    tabela = [{b: sum(s[i] == b for s in seqs) + pseudocontagem for b in alfabeto} for i in range(L)]

    pwm = [{k: v / (len(seqs) + A * pseudocontagem) for k, v in linha.items()} for linha in tabela]

    pssm = [
        {k: round(log2(pwm[i][k] / bg_freq[k]), casas_decimais) if pwm[i][k] > 0 else float("-inf")
         for k in pwm[i]}
        for i in range(L)
    ]

    prob_seq = prod(pwm[i].get(seq[i], 0) for i in range(len(pwm)) if seq[i] in pwm[i])

    motif_len = len(pwm)
    subseqs = findall(f'(?=(.{{{motif_len}}}))', seq)
    subseqs = [s for s in subseqs if all(c in pwm[0] for c in s)]
    probs = {s: prod(pwm[i].get(s[i], 0) for i in range(motif_len)) for s in subseqs}
    max_prob = max(probs.values(), default=0)
    seqs_mais_probaveis = sorted(k for k, v in probs.items() if v == max_prob)

    return pwm, pssm, prob_seq, (seqs_mais_probaveis, max_prob)

"""TESTES UNITARIOS (PSSM, PWM, SEQUENCIA MAIS PROVAVEL)"""

class TestPWMPSSMSequencia(unittest.TestCase):
    def setUp(self):
        self.seqs = ["ACGT", "ACGA", "ACGG", "ACGC"]
        self.seq = "ACGTACGGACGC"
        self.pseudocontagem = 1
        self.bg_freq = {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}
        self.casas_decimais = 2

    def test_sequencias_tamanho_diferente(self):
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(["ACGT", "ACGA", "ACG"], "ACGTACGGACGC")

    def test_sequencia_menor_que_motivo(self):
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(["ACGT", "ACGA", "ACGG", "ACGC"], "ACG")

    def test_tipo_invalido(self):
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(["ACGT", "ACGA", "ACGG", "ACGC"], "ACGTACGGACGC", tipo="RNA")

    def test_pwm_calculation(self):
        pwm, _, _, _ = pwm_pssm_e_sequencia_mais_provavel(
            self.seqs, self.seq, pseudocontagem=self.pseudocontagem,
            casas_decimais=self.casas_decimais, bg_freq=self.bg_freq
        )

        N = len(self.seqs)
        A = 4
        pc = self.pseudocontagem

        self.assertTrue(isclose(pwm[0]['A'], (4 + pc)/(N + A*pc), rel_tol=1e-2))
        self.assertTrue(isclose(pwm[0]['C'], (0 + pc)/(N + A*pc), rel_tol=1e-2))
        self.assertTrue(isclose(pwm[0]['G'], (0 + pc)/(N + A*pc), rel_tol=1e-2))
        self.assertTrue(isclose(pwm[0]['T'], (0 + pc)/(N + A*pc), rel_tol=1e-2))

        for pos in range(len(pwm)):
            prob_sum = sum(pwm[pos].values())
            self.assertTrue(isclose(prob_sum, 1.0, rel_tol=1e-2))

    def test_pssm_calculation(self):
        _, pssm, _, _ = pwm_pssm_e_sequencia_mais_provavel(
            self.seqs, self.seq, pseudocontagem=self.pseudocontagem,
            casas_decimais=self.casas_decimais, bg_freq=self.bg_freq
        )

        for pos in range(len(pssm)):
            for base in 'ACGT':
                self.assertTrue(isinstance(pssm[pos][base], float))
                if pssm[pos][base] != float('-inf'):
                    self.assertTrue(-10 <= pssm[pos][base] <= 10)

    def test_sequencia_mais_provavel(self):
        _, _, _, (seqs_provaveis, prob) = pwm_pssm_e_sequencia_mais_provavel(
            self.seqs, self.seq, pseudocontagem=self.pseudocontagem,
            casas_decimais=self.casas_decimais, bg_freq=self.bg_freq
        )

        self.assertTrue(len(seqs_provaveis) > 0)
        self.assertTrue(0 <= prob <= 1)
        for seq in seqs_provaveis:
            self.assertEqual(len(seq), len(self.seqs[0]))

if __name__ == "__main__":
    suite = unittest.TestLoader().loadTestsFromTestCase(TestPWMPSSMSequencia)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    if result.wasSuccessful():
        print("All tests passed!")
    else:
        print("Some tests failed.")

"""Função para encontrar motivos determinísticos ou estocásticos"""

def encontrar_motivos(seqs, pwm=None, tipo="deterministico", threshold=0.1):
    """
    Encontra motivos determinísticos ou estocásticos nas sequências fornecidas.

    - Motivos determinísticos são padrões exatos que aparecem em todas as sequências.
    - Motivos estocásticos são determinados com base nas probabilidades da PWM.

    Args:
        seqs: Lista de sequências (de DNA ou proteína) para procurar os motivos.
        pwm: PWM calculada a partir das sequências (necessária para motivos estocásticos).
        tipo: Tipo de motivo a ser encontrado, pode ser "deterministico" ou "estocastico".
        threshold: Limite de probabilidade para considerar um motivo válido (apenas para motivos estocásticos).

    Returns:
        motivos: Lista com os motivos encontrados.
    """
    if tipo == "deterministico":
        L = len(seqs[0])
        motivos = []

        for i in range(len(seqs[0]) - L + 1):
            subseq = seqs[0][i:i+L]
            if all(subseq in s for s in seqs):
                motivos.append(subseq)

        return list(set(motivos))

    elif tipo == "estocastico":
        if pwm is None:
            raise ValueError("PWM deve ser fornecida para encontrar motivos estocásticos.")

        L = len(pwm)
        motivos_estocasticos = []

        for seq in seqs:
            from re import findall
            subseqs = findall(f'(?=(.{{{L}}}))', seq)
            for subseq in subseqs:
                prob = 1
                for i in range(L):
                    prob *= pwm[i].get(subseq[i], 0)

                if prob >= threshold:
                    motivos_estocasticos.append(subseq)

        return list(set(motivos_estocasticos))

    else:
        raise ValueError("Tipo inválido. Escolha entre 'deterministico' ou 'estocastico'.")

"""TESTES UNITARIOS (Motivos Determinísticos ou Estocásticos)"""

class TestPWM_PSSM(unittest.TestCase):

    def test_pwm_pssm_calculation_valid_input(self):
        seqs = ["ATGCATGC", "ATGCATGC", "ATGCATGC"]
        seq = "ATGCATGC"
        pwm, pssm, prob_seq, seqs_mais_probaveis = pwm_pssm_e_sequencia_mais_provavel(seqs, seq)

        self.assertIsInstance(pwm, list)
        self.assertIsInstance(pwm[0], dict)

        self.assertIsInstance(pssm, list)
        self.assertIsInstance(pssm[0], dict)

    def test_invalid_sequences_length(self):
        seqs = ["ATGCATGC", "ATGCATGC"]
        seq = "ATGC"
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(seqs, seq)

    def test_invalid_characters_in_sequences(self):
        seqs = ["ATGCATGC", "ATGXATGC"]
        seq = "ATGCATGC"
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(seqs, seq)

    def test_invalid_alphabet_type(self):
        seqs = ["ATGCATGC", "ATGCATGC"]
        seq = "ATGCATGC"
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(seqs, seq, tipo="RNA")

    def test_background_frequency_check(self):
        seqs = ["ATGCATGC", "ATGCATGC"]
        seq = "ATGCATGC"
        bg_freq = {'A': 0.25, 'C': 0.25, 'G': 0.25}
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(seqs, seq, bg_freq=bg_freq)

    def test_empty_sequences(self):
        seqs = []
        seq = "ATGCATGC"
        with self.assertRaises(ValueError):
            pwm_pssm_e_sequencia_mais_provavel(seqs, seq)

    def test_probabilidade_com_zeros(self):
        seqs = ["ATGCATGC", "ATGCATGC", "ATGCATGC"]
        seq = "AAAAAAA"
        pwm, pssm, prob_seq, seqs_mais_probaveis = pwm_pssm_e_sequencia_mais_provavel(seqs, seq)
        self.assertEqual(prob_seq, 0.0)

if __name__ == "__main__":
    suite = unittest.TestLoader().loadTestsFromTestCase(TestPWMPSSMSequencia)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    if result.wasSuccessful():
        print("All tests passed!")
    else:
        print("Some tests failed.")